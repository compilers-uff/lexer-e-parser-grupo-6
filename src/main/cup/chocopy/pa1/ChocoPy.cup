import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
terminal NEWLINE;
terminal INDENT;
terminal DEDENT;
terminal String UMINUS;
terminal Integer NUMBER;
terminal String IDENTIFIER;
terminal String ARROW;
terminal String PLUS;
terminal String MINUS;
terminal String TIMES;
terminal String FLOORDIV;
terminal String MOD;
terminal String LE;
terminal String GE;
terminal String EQ;
terminal String NE;
terminal String LT;
terminal String GT;
terminal String ASSIGN;
terminal String LPAREN;
terminal String RPAREN;
terminal String LBRACKET;
terminal String RBRACKET;
terminal String COMMA;
terminal String COLON;
terminal String DOT;
terminal boolean FALSE;
terminal String NONE;
terminal boolean TRUE;
terminal String AND;
terminal String AS;
terminal String ASSERT;
terminal String ASYNC;
terminal String AWAIT;
terminal String BREAK;
terminal String CLASS;
terminal String CONTINUE;
terminal String DEF;
terminal String DEL;
terminal String ELIF;
terminal String ELSE;
terminal String EXCEPT;
terminal String FINALLY;
terminal String FOR;
terminal String FROM;
terminal String GLOBAL;
terminal String IF;
terminal String IMPORT;
terminal String IN;
terminal String IS;
terminal String LAMBDA;
terminal String NONLOCAL;
terminal String NOT;
terminal String OR;
terminal String PASS;
terminal String RAISE;
terminal String RETURN;
terminal String TRY;
terminal String WHILE;
terminal String WITH;
terminal String YIELD;
terminal String STRING;
/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;   

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program           program;
non terminal List<Declaration> program_head,declaration_list,class_body,var_def_list,func_def_list,func_declarations;
non terminal List<Stmt>        stmt_list, opt_stmt_list,block;
non terminal List<Expr>        expr_list;
non terminal List<Expr> chained_assigns;
non terminal Stmt              stmt,simple_stmt,elif_stmt;
non terminal Expr              expr,cexpr;
non terminal Identifier        identifier; 
non terminal IndexExpr         index_expr;
non terminal MemberExpr        member_expr;
non terminal Literal           literals;
non terminal Declaration       declaration,class_body_declaration;
non terminal ClassDef          class_def;
non terminal VarDef            var_def;
non terminal FuncDef           func_def;
non terminal TypedVar          typed_var;
non terminal TypeAnnotation   type;
non terminal GlobalDecl        global_decl;
non terminal NonLocalDecl      nonlocal_decl;
non terminal List<TypedVar>    typed_var_list;


/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc EQ, NE, LT, GT, LE, GE, IS;
precedence left PLUS, MINUS;
precedence left TIMES, FLOORDIV, MOD;
precedence left UMINUS;
precedence left DOT, COMMA, LBRACKET, RBRACKET;
precedence right IF, ELSE;
precedence left LPAREN,RPAREN;

/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/


program ::= program_head:d opt_stmt_list:s {: RESULT = new Program(dxleft,sxright, d, s, errors); :}
          | opt_stmt_list:s {: RESULT = new Program(sxleft,sxright, empty(), s, errors); :}
          ;


program_head ::= declaration:d {: RESULT = single(d); :}
                   | program_head:l declaration:d {: RESULT = combine(l,d); :}
                   | program_head:l error     {: RESULT = l; :}
                   ;

declaration ::= class_def:cd {: RESULT = cd; :}
              | func_def:fd {: RESULT = fd; :}
              | var_def:vd {: RESULT = vd; :}
              ;

class_def ::= CLASS:cop identifier:id1 LPAREN identifier:id2 RPAREN COLON NEWLINE INDENT class_body:cb DEDENT:dde {: RESULT = new ClassDef(copxleft,ddexright,id1,id2,cb); :}
            ;

class_body ::= class_body_declaration:d {: RESULT = single(d); :}
                   | class_body:l class_body_declaration:d {: RESULT = combine(l,d); :}
                   | class_body:l error     {: RESULT = l; :}
                   ;

class_body_declaration ::= PASS NEWLINE {: RESULT = null; :}
             | var_def:vd {: RESULT = vd; :}
             | func_def:fd {: RESULT = fd; :}
             | NEWLINE {: RESULT = null; :}
             ;


var_def_list ::= var_def:v {: RESULT = single(v); :}
               | var_def_list:l var_def:v {: RESULT = combine(l, v); :}
               | var_def_list:l error     {: RESULT = l; :}
               ;

func_def_list ::= func_def:f {: RESULT = single(f); :}
               | func_def_list:l func_def:f {: RESULT = combine(l, f); :}
               | func_def_list:l error     {: RESULT = l; :}
               ;

func_def ::= DEF:first identifier:id LPAREN RPAREN COLON NEWLINE INDENT func_declarations:d stmt_list:s DEDENT:last {: RESULT =  new FuncDef(firstxleft,lastxright,id,empty(),null,d,s); :}
           | DEF:first identifier:id LPAREN typed_var_list:tl RPAREN COLON NEWLINE INDENT func_declarations:d stmt_list:s DEDENT:last {: RESULT =  new FuncDef(firstxleft,lastxright,id,tl,null,d,s); :}
           | DEF:first identifier:id LPAREN  RPAREN ARROW type:ta COLON NEWLINE INDENT func_declarations:d stmt_list:s DEDENT:last {: RESULT =  new FuncDef(firstxleft,lastxright,id,empty(),ta,d,s); :}
           | DEF:first identifier:id LPAREN typed_var_list:tl RPAREN ARROW type:ta COLON NEWLINE INDENT func_declarations:d stmt_list:s DEDENT:last {: RESULT =  new FuncDef(firstxleft,lastxright,id,tl,ta,d,s); :}
           ;

func_declarations ::= global_decl:g                 {: RESULT = single(g); :}
            | nonlocal_decl:nl                 {: RESULT = single(nl); :}
            | var_def:v                 {: RESULT = single(v); :}
            | func_def:f                 {: RESULT = single(f); :}
            | func_declarations:l global_decl:g      {: RESULT = combine(l, g); :}
            | func_declarations:l nonlocal_decl:nl     {: RESULT = combine(l, nl); :}
            | func_declarations:l var_def:v      {: RESULT = combine(l, v); :}
            | func_declarations:l func_def:f      {: RESULT = combine(l, f); :}
            | func_declarations:l error     {: RESULT = l; :}
            ;

typed_var_list ::= typed_var:t {: RESULT = single(t); :}
                 | typed_var_list:l COMMA typed_var:t {: RESULT = combine(l,t); :}
                 | typed_var_list:l error {: RESULT = l; :}
                 ;

typed_var ::= identifier:id COLON type:ty {: RESULT = new TypedVar(idxleft,tyxright,id,ty); :}
            ;

type ::= IDENTIFIER:id {: RESULT = new ClassType(idxleft,idxright,id); :}
       | LBRACKET type:t RBRACKET {: RESULT = t; :}
       ;

global_decl ::= GLOBAL:first identifier:id NEWLINE:last {: RESULT = new GlobalDecl(firstxleft,lastxright,id); :}
              ;

nonlocal_decl ::= NONLOCAL:first identifier:id NEWLINE:last {: RESULT = new NonLocalDecl(firstxleft,lastxright,id); :}
                ;

var_def ::= typed_var:ty ASSIGN literals:value NEWLINE:last {: RESULT = new VarDef(tyxleft,lastxright,ty,value); :}
          ;

opt_stmt_list ::=                    {: RESULT = empty(); :}
                | stmt_list:s        {: RESULT = s; :}
                ;

stmt_list ::= stmt:s                 {: RESULT = single(s); :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error     {: RESULT = l; :}
            /* If there is a syntax error in the source, this says to discard
             * symbols from the parsing stack and perform reductions until
             * there is a stmt_list on top of the stack, and then to discard
             * input symbols until it is possible to shift again, reporting
             * a syntax error. */
            ;

stmt ::= simple_stmt:s NEWLINE {: RESULT = s; :}
       | IF:op expr:e COLON block:then elif_stmt:l {: RESULT = new IfStmt(opxleft,thenxright,e,then,single(l)); :}
       | IF:op expr:e COLON block:then {: RESULT = new IfStmt(opxleft,thenxright,e,then,empty()); :}
       | IF:op expr:e COLON block:then ELSE COLON block:elseblock {: RESULT = new IfStmt(opxleft,elseblockxright,e,then,elseblock); :}
       | WHILE:whileop expr:e COLON block:doblock {:  RESULT = new WhileStmt(whileopxleft,doblockxright,e,doblock); :}
       | FOR:forop identifier:id IN expr:e COLON block:doblock {: RESULT = new ForStmt(foropxleft,doblockxright,id,e,doblock); :}
       | NEWLINE {: RESULT = null; :}
       ;

elif_stmt ::= ELIF:op expr:e COLON block:then elif_stmt:l {: RESULT = new IfStmt(opxleft,thenxright,e,then,single(l)); :}
            | ELIF:op expr:e COLON block:then ELSE COLON block:elseblock {: RESULT = new IfStmt(opxleft,thenxright,e,then,elseblock); :}
            | ELIF:op expr:e COLON block:then {: RESULT = new IfStmt(opxleft,thenxright,e,then,empty()); :}
            ;

simple_stmt ::= PASS {: RESULT = null; :}
              | expr:e {: RESULT = new ExprStmt(exleft,exright,e); :}
              | RETURN expr:e {: RESULT = new ReturnStmt(exleft,exright,e); :}
              | RETURN {: RESULT = null; :}
              | chained_assigns:idlist ASSIGN expr:e {: RESULT = new AssignStmt(idlistxleft,exright,idlist,e); :}
              ;



block ::= NEWLINE INDENT stmt_list:s DEDENT {: RESULT = s; :}
        ;


expr_list ::= expr:e                 {: RESULT = single(e); :}
            | expr_list:l COMMA expr:e   {: RESULT = combine(l,e); :}
            | expr_list:l error    {: RESULT = l; :}
            ;



expr ::= cexpr:e {: RESULT = e; :}
       | NOT:op expr:e {: RESULT = new UnaryExpr(opxleft,exright,op,e); :}
       | expr:e1 AND:op expr:e2 {: RESULT = new BinaryExpr(e1xleft,e2xright,e1,op,e2); :}
       | expr:e1 IF expr:e2 ELSE expr:e3 {: RESULT = new IfExpr(e1xleft,e3xright,e2,e1,e3); :} 
       ;


literals ::= FALSE:f {: RESULT = new BooleanLiteral(fxleft,fxright,f); :}
               | TRUE: t {: RESULT = new BooleanLiteral(txleft,txright,t); :}
               | NONE: non {: RESULT = new NoneLiteral(nonxleft,nonxright); :}
               | STRING:str {: RESULT = new StringLiteral(strxleft,strxright,str.substring(1, str.length() - 1)); :}
               | NUMBER:num       {: RESULT = new IntegerLiteral(numxleft, numxright, num); :}
               ;


cexpr ::= literals:l {: RESULT = l; :}
        | cexpr:e1 PLUS:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 MINUS:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 TIMES:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 FLOORDIV:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 MOD:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 LE:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 GE:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 EQ:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 NE:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 GT:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 LT:op cexpr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | member_expr:me {: RESULT = me; :}
        | index_expr:ie {: RESULT = ie; :}
        | LBRACKET:first expr_list:l RBRACKET:r {:RESULT =  new ListExpr(firstxleft,rxright,l); :} 
        | member_expr:me LPAREN LBRACKET expr_list:l RBRACKET RPAREN:rp {: RESULT = new MethodCallExpr(mexleft,rpxright,me,l); :}
        | identifier:id LPAREN expr_list:l RPAREN:rp {: RESULT = new CallExpr(idxleft,rpxright,id,l); :}
        | LBRACKET:l RBRACKET:r {: RESULT =  new ListExpr(lxleft,rxright,empty()); :} 
        | member_expr:me LPAREN LBRACKET RBRACKET RPAREN:rp {: RESULT = new MethodCallExpr(mexleft,rpxright,me,empty()); :}
        | identifier:id LPAREN RPAREN:rp {: RESULT = new CallExpr(idxleft,rpxright,id,empty()); :}
        | MINUS:op cexpr:e {: RESULT = new UnaryExpr(opxleft, exright,op,e); :}
        | LPAREN expr:e RPAREN {: RESULT = e; :}
        | identifier:id {: RESULT = id; :}
        ;

identifier ::=  IDENTIFIER:id {: RESULT = new Identifier(idxleft,idxright,id); :}
            ;

index_expr ::= cexpr:e1 LBRACKET expr:e2 RBRACKET:rb {: RESULT = new IndexExpr(e1xleft,rbxright,e1,e2); :}
             ;

member_expr ::= cexpr:obj DOT identifier:member {: RESULT = new MemberExpr(objxleft,memberxright,obj,member); :}
              ;

chained_assigns ::= chained_assigns:l ASSIGN identifier:id {: RESULT = combine(l,id); :}
                  | chained_assigns:l ASSIGN index_expr:ie {: RESULT = combine(l,ie); :}
                  | chained_assigns:l ASSIGN member_expr:me {: RESULT = combine(l,me); :}
                  | identifier:id {: RESULT = single(id); :}
                  | index_expr:ie {: RESULT = single(ie); :}
                  | member_expr:me {: RESULT = single(me); :}
                  ;
